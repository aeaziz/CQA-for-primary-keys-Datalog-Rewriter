# CQA for primary keys Datalog Rewriter
## Introduction
This is a python script that generates a Datalog program for the problem know in the litterature as CQA.
By default, it takes as input a file containing a sjfBCQ query and writes the output program in a file named "output.txt", but the main.py file can be easily modified to change this behavior.
## References
* Jef Wijsen Paraschos Koutris.  Consistent query answering for self-join-free conjunctive queries under primary key constraints.  2017.
* Jef Wijsen Paraschos Koutris.  Consistent query answering for primarykeys in datalog.  2019.
* Jef Wijsen. Certain conjuctive query answering in first-order logic. 2012.
## What is a CQA Problem?
**CQA** for primary keys is the following problem:

Given a database **db** that may violate its primary-key constraints, multiple reparations can be generated by deleting a minimal set of tuples from **db**. 
For every sjfCBQ **q**, **CERTAINTY(q)** is the problem that takes as input **db** and asks whether **q** evaluates true for every reparation of **db**.

This scripts impliments **CERTAINTY(q)** in a **Datalog** program.
## Usage
The main script takes as input a sjfBCQ using a specific syntax.
The syntax is essentially the same than Datalog queries, but extending it with key-values being surrounded by [ ]

Example : R([X],Y),S([Y],X) is a valid query.
## How does it work?
The articles in the References section talk about how the complexity of **CERTAINTY(q)** can be determined. 
This code generates all the necessary tools (Attack Graph) to find the complexity of **CERTAINTY(q)**.
As it is specified in the articles, there're 3 cases:

* **CERTAINTY(Q)** is in **FO**
* **CERTAINTY(Q)** is in **L**
* **CERTAINTY(Q)** is in **Co-NPHard**

For the 2 first cases, a Datalog rewrite is possible. The third case can be detected but a rewriting is not possible.

### Rewriting an unattacked atom
We say that an atom A is unattacked if for every atom B, there isn't an edge A->B in the attack graph.
Theory tells us that in that case, this atom can be rewrited in FO. The 2012 article gives us this formula :

![f1]

Where ![v] is the sequence of variables appearing in R.

A Datalog rewriting of this formula:

```
R_0 :- R(![x],![y]), not R_1(![x])
R_1(![x]) :- R(![x],![z1], ![z2]), not R_2(![x],![z1],![z2])
R_2(![x],![y],![z2]) :- R(![x],![z1], ![z2]), C, R_3(![x],![y])
```

[f1]: http://chart.apis.google.com/chart?cht=tx&chl=\exists\vec{v},R(\underline{\vec{x}},\vec{y})\wedge\forall\vec{z}(R(\underline{\vec{x}},\vec{z})\rightarrow(C\wedge\phi(\vec{v})))  

[x]: http://chart.apis.google.com/chart?cht=tx&chl=\underline{\vec{x}}
[y]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{v} 
[v]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{v} 
[z]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{z} 
[z1]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{z_1} 
[z2]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{z_2} 




