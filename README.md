# CQA for primary keys Datalog Rewriter
## Introduction
This is a python script that generates a Datalog program for the problem know in the litterature as CQA.
By default, it takes as input a file containing a sjfBCQ query and writes the output program in a file named "output.txt", but the main.py file can be easily modified to change this behavior.
## References
* Jef Wijsen Paraschos Koutris.  Consistent query answering for self-join-free conjunctive queries under primary key constraints.  2017.
* Jef Wijsen Paraschos Koutris.  Consistent query answering for primarykeys in datalog.  2019.
* Jef Wijsen. Certain conjuctive query answering in first-order logic. 2012.
## What is a CQA Problem?
**CQA** for primary keys is the following problem:

Given a database **db** that may violate its primary-key constraints, multiple reparations can be generated by deleting a minimal set of tuples from **db**. 
For every sjfCBQ **q**, **CERTAINTY(q)** is the problem that takes as input **db** and asks whether **q** evaluates true for every reparation of **db**.

This scripts impliments **CERTAINTY(q)** in a **Datalog** program.
## Usage
The main script takes as input a sjfBCQ using a specific syntax.
The syntax is essentially the same than Datalog queries, but extending it with key-values being surrounded by [ ]

Example : R([X],Y),S([Y],X) is a valid query.
## How does it work?
The articles in the References section talk about how the complexity of **CERTAINTY(q)** can be determined. 
This code generates all the necessary tools (Attack Graph) to find the complexity of **CERTAINTY(q)**.
As it is specified in the articles, there're 3 cases:

* **CERTAINTY(Q)** is in **FO**
* **CERTAINTY(Q)** is in **L**
* **CERTAINTY(Q)** is in **Co-NPHard**

For the 2 first cases, a Datalog rewrite is possible. The third case can be detected but a rewriting is not possible.

### Rewriting an unattacked atom
We say that an atom A is unattacked if for every atom B, there isn't an edge B->A in the attack graph.
Theory tells us that in that case, this atom can be rewrited in FO. The 2012 article gives us this formula :

![f1]

Where :
* ![v] is the sequence of variables appearing in R.
* C is a set of equalities initially empty.
* ![z] is a vector with the same size of ![y] which is constructed in the following way for every ![yi] in ![y]:
	* if ![yi] appears in ![x], ![yi] is a constant or for some j, then ![zi] is a fresh variable and C contains  ![zi] = ![yi]
	* else, ![zi] = ![yi]

To make easier the Datalog rewrite, i use a supplementary vector ![z1] that contains every fresh variable ![zi].
A Datalog rewriting of this formula:

```
R_0 :- R(X,Y), not R_1(X)
R_1(X) :- R(X,Z), not R_2(X,Z,Z1)
R_2(X,Y,Z1) :- R(X,Y), C, R_3(X,Y)
```

Where X,Y,Z,Z1 take the values from vectors ![x], ![y], ![z], ![z1].
Notice that rule R_2 is safe as Z1 is a subset of Y and appears in C.

[f1]: http://chart.apis.google.com/chart?cht=tx&chl=\exists\vec{v},R(\underline{\vec{x}},\vec{y})\wedge\forall\vec{z}(R(\underline{\vec{x}},\vec{z})\rightarrow(C\wedge\phi(\vec{v})))  

[x]: http://chart.apis.google.com/chart?cht=tx&chl=\underline{\vec{x}}
[y]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{y}
[yi]: http://chart.apis.google.com/chart?cht=tx&chl=y_i 
[yj]: http://chart.apis.google.com/chart?cht=tx&chl=y_j 
[v]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{v} 
[z]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{z} 
[zi]: http://chart.apis.google.com/chart?cht=tx&chl=z_i 
[z1]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{z_1} 
[z2]: http://chart.apis.google.com/chart?cht=tx&chl=\vec{z_2} 




